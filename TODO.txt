
 * Basic Networking: IPv4, UDP and RAW sockets, over SLIP.

 * Fix the optimization problem

 * Change Mutex system: work with variables instead of SO internat slots.

 * Create tests dir with multiple programs to make stress tests.

 * Port AppOS to Arduino.

 * Full Networking (IPv6, TCP)
		Free IP stacks:
		uIP (https://github.com/adamdunkels/uip)
		lwIP (http://savannah.nongnu.org/projects/lwip/)

 * Real Time system for core/task:

		TASK core_resident(void (*task)(void *, size_t), PRIORITY priority, size_t stackSize)

		This function creates a new task with state TASK_STATE_RESIDENT, that is ignored by the task scheduler, so it won't get CPU time.
		Unlike the normal tasks, this functions takes two arguments: void *buffer, size_t size
		A buffer of data and the size of the buffer.

		int core_wakeup(TASK taskID, void *buff, size_t size)

		With this other function we send an event to a resident task. By doing this, the task state changes to TASK_STATE_RESIDENT_RUNNING,
		and is executed passing to the function the arguments buff and size.

		It returns 0 if ok
		If the task is bussy attending a previous event (it was already in state TASK_STATE_RESIDENT_RUNNING), returns ERR_TASK_BUSSY.
		If the task is not resident, returns ERR_TASK_NO_RESIDENT.

		When a resident task ends, instead of being deleted as any other task, it goes back to the state TASK_STATE_RESIDENT and is ready to receive more events.

 * File System module

 * Port AppOS to RasPi and microbit.

 * Langs: C++, Lua and Google Blocky (compiles to Lua).

 * USB: host controller driver and libUSB-like interface for API (or port libUSB).
		PCI interface (required for USB suport in PC32 arch)

 * Interface for other serial ports (SPI & I2C), create modules "spi_" and "i2c_".

 * Implement SMP

 * Memory Protection: implement a "supervisor" module who takes care of forbidden memory access, program memory integrity, illegal opcode execution, exceptions, etc.
		Also create a small API to control its behaviour from the app, what do to in case of a exception (reset, halt, fallback function, etc). In this mode, the
		kernel + app code resides in a read only segment, the kernel internal mem structures in a protected segment, the stack in another segment and the heap in another segment.

 * Console (screen + keyboard) driver for term (low priority)
