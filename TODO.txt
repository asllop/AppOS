
 * Basic Networking: IPv4, UDP and RAW sockets, over SLIP.
 
 * Fix the gcc optimization problem:
   - Use "-O2" gcc flag.
   - Declare volatile all the global variables declared in modules (instead of static or any other qualifier).
   - Declare volatile all the memory structures, but not the logic ones (not necessary).
   - Declare static the private functions only used inside is file.
   - Make sure none of the variables are declared static, since it doesn't make sense in the context of AppOS.
   - Use "optimize ("O0")" for some code blocks or functions to disable gcc optimizations localy.
   - Use volatile as a qualifier for casting memory access that are sensitive.
   - Start with only Core, fix it and then add modules progresively. Or even start with parts of Core.
   - Refs:
   https://wiki.osdev.org/Optimizing
   https://wiki.osdev.org/Volatile_(keyword)
   https://stackoverflow.com/questions/2219829/how-to-prevent-gcc-optimizing-some-statements-in-c
   https://www.youth4work.com/es/Talent/C-Language/Forum/118628-what-is-the-use-of-static-variable-in-c
   
 
 * Change Mutex system: work with local variables (structs) and pointers to it, instead of SO global slots.
  
 * Doxygen docs.
 
 * Improve the NET iface management, now selection of iface is manual (hardcoded to 0 in some cases).

 * Examine all TODO's in the code.

 * Create tests dir with multiple programs to make stress tests:
   - MEM: multiples tasks amb diferents prioritats, que reserven memoria, la omplen de dades (contador) amb sleeps entre mig i després miren que tot estigui bé.
          cada cop que es fa una iteració es mira que el buffer encara sigui vàlid i tingui la mida que tenia.
   - TASK: crear multiples tasques amb diferents prioritats, arrencar, acabar les tasques. Posar sleeps, mutex, etc.
   - NET: crear multiples sockets, en diferents taskes, accedint al mateix i a diferents sockets. Enviant informació entre ells i a altres hosts.

 * Port AppOS to Arduino.
 * Port AppOS to NRF51/52 (micro:bit).
 * Port AppOS to RaspberryPi

 * Langs: C++, Lua and Google Blocky (compiles to Lua).

 * Full Networking (TCP, IPv6)
		Free IP stacks:
		uIP (https://github.com/adamdunkels/uip)
		lwIP (http://savannah.nongnu.org/projects/lwip/)

 * Sequential Threads (SeqThr): to avoid the usage of mutex in simple cases, we could create a thread that is not concurrent with another selected one and only runs
   when the principal thread goes to sleep voluntarily. When core_sleep is called, if any SeqThr in the queue, then sleep and run it, if not, just continue normaly.
   Example:

// This threas has task id == ID_MAIN
void main_thread()
{
   for (;;)
   {
      // Do stuff ...
   
      core_sleep(XX);

      // ...
   }
}

// Some where else...
core_attach(ID_MAIN, foo);

// Sequential Thread
void foo()
{
   // Do stuff...
   
   // Return and End function
}

The "foo" must end in order to return the control to main_thread, because when attached and called it becomes part of the main_thread.
Once foo is finished, it is detached from the queue and never executed again. It must be attached again to be run. If multiple attaches, the SeqThr
are executed sequentialy, taken from the queue, executed and removed.

NOTE: Do not make it part of the Core module. Too complex.

 * Real Time system for core/task:

		TASK core_resident(void (*task)(), PRIORITY priority, size_t stackSize)

		This function creates a new task with status TASK_STATE_RESIDENT, that is ignored by the task scheduler, so it won't get CPU time.

		int core_wakeup(TASK taskID, void *userData)

		With this other function we send an event to a resident task. By doing this, the task state changes to TASK_STATE_RESIDENT_RUNNING and is executed setting the userData. Once the wake event is sent, the task starts immediately passing over any other currently being executed and the schedling timers is reset. After the first context change, the resident task works as a normal task and scheduling happens as usual.

		It returns 0 if ok
		If the task is bussy attending a previous event (it was already in state TASK_STATE_RESIDENT_RUNNING), returns ERR_TASK_BUSSY.
		If the task is not resident, returns ERR_TASK_NO_RESIDENT.

		When a resident task ends, instead of being deleted as any other task, it goes back to the state TASK_STATE_RESIDENT and is ready to receive more events.
		
 * PROPOSAL: Create a "rt" module, outside of core, and add there the task extensions: resident, wakeup and attach. To keep core small and simple.

 * File System module.

 * USB: host controller driver and libUSB-like interface for API (or port libUSB).
		PCI interface (required for USB suport in PC32 arch)

 * Interface for other serial ports (SPI & I2C), create modules "spi_" and "i2c_".

 * Implement SMP.

 * Memory Protection (low priority): implement a "supervisor" module who takes care of forbidden memory access, program memory integrity, illegal opcode execution, exceptions, etc.
		Also create a small API to control its behaviour from the app, what do to in case of a exception (reset, halt, fallback function, etc). In this mode, the
		kernel + app code resides in a read only segment, the kernel internal mem structures in a protected segment, the stack in another segment and the heap in another segment.

 * Console (screen + keyboard) driver for term (low priority)
